import asyncio
import datetime
import typing

from payme_api.models.insert_check_to_db import InsertCreatedCheck
from click_api.models.insert_order import InsertCreatedOrder
from click_api.models.update_prepare import PrepareUpdate
import asyncpg
from natsort import natsorted
from datetime_now.datetime_now import dt_now
import config
from typing import List
from text.language.main import Text_main
Txt = Text_main()
from database.data_center import regions, cars
# from text.text_func import TextFunc
#
# func = TextFunc()


class Database:
    def __init__(self, loop: asyncio.AbstractEventLoop):
        self.__time = None
        self.pool: asyncio.pool.Pool = loop.run_until_complete(
            asyncpg.create_pool(
                database="taxi",
                user=config.PGUSER,
                password=config.PASSWORD,
                host=config.ip,
            )
        )

    async def sql_start(self):
        if self.pool:
            print('Data base connected ok!')
            await self.create_table_regions()
            await self.create_table_cars()
            await self.create_table_all_users()
            await self.create_table_drivers()
            await self.create_table_route_driver()
            await self.create_table_orders_client()
            await self.create_table_orders_driver()
            await self.create_table_orders_accepted()
            await self.create_wallet_pay()
            await self.create_table_transactions()
            await self.create_table_click_tran()
            await self.create_table_quiz()
            await self.create_table_analise_client()
            await self.create_table_analise_driver()
            await self.add_cars(cars=cars)
            # await self.add_regions(regions=regions)

    #######
    async def create_table_regions(self):
        sql1 = """CREATE TABLE IF NOT EXISTS regions(
                region_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                region_rus VARCHAR(255) NOT NULL, 
                town_rus VARCHAR(255) NOT NULL,
                region_uzb VARCHAR(255) NOT NULL, 
                town_uzb VARCHAR(255) NOT NULL,
                region_ozb VARCHAR(255) NOT NULL, 
                town_ozb VARCHAR(255) NOT NULL)"""
        await self.pool.execute(sql1)

    async def create_table_cars(self):
        sql6 = """CREATE TABLE IF NOT EXISTS cars(
                car_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                car VARCHAR(255) NOT NULL
                )"""
        await self.pool.execute(sql6)

    async def create_table_all_users(self):
        sql2 = """CREATE TABLE IF NOT EXISTS all_users(
                id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id BIGINT NOT NULL, 
                name VARCHAR(255) NOT NULL, 
                username VARCHAR(255),
                phone VARCHAR(255),
                language VARCHAR(255),
                status BOOL,
                deeplink VARCHAR(255),
                datetime_registration timestamp NOT NULL
                )"""
        await self.pool.execute(sql2)

    async def create_table_drivers(self):
        sql3 = """CREATE TABLE IF NOT EXISTS drivers(
                id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                driver_id BIGINT NOT NULL,
                name VARCHAR(255) NOT NULL,
                username VARCHAR(255),
                phone BIGINT NOT NULL,             
                car BIGINT NOT NULL,
                datetime_registration timestamp NOT NULL,
                wallet_main BIGINT NOT NULL,
                wallet_bonus BIGINT NOT NULL,
                wallet_holiday BIGINT NOT NULL
                )"""
        await self.pool.execute(sql3)

    async def create_table_route_driver(self):
        sql4 = """CREATE TABLE IF NOT EXISTS route_driver(      
                route_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                driver_id BIGINT NOT NULL,
                name VARCHAR(255) NOT NULL,
                phone BIGINT NOT NULL,
                car BIGINT NOT NULL,
                
                from_region BIGINT NOT NULL,
                from_towns BIGINT[],
                to_region BIGINT NOT NULL,                
                to_towns BIGINT[],
                conditioner BIGINT NOT NULL,
                price BIGINT NOT NULL,             
                
                datetime_open timestamp NOT NULL,
                datetime_close timestamp,
                cancel BOOL
                )"""
        await self.pool.execute(sql4)

    async def create_table_orders_client(self):
        sql5 = """CREATE TABLE IF NOT EXISTS orders_client(
                order_client_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                order_driver_id BIGINT NOT NULL,
                client_id BIGINT NOT NULL,
                type_of_application VARCHAR(255) NOT NULL,              
                
                from_region BIGINT NOT NULL,
                from_town BIGINT NOT NULL,
                to_region BIGINT NOT NULL,
                to_town BIGINT NOT NULL,
                
                date_trip DATE NOT NULL,
                time_trip VARCHAR(255)[],
                places BIGINT,
                baggage BIGINT NOT NULL,
                trip BIGINT NOT NULL,
                phone BIGINT NOT NULL,
                
                route_id BIGINT NOT NULL,
                cost BIGINT NOT NULL,
                
                datetime_open timestamp NOT NULL,                  
                order_accept BOOL                     
                )"""
        await self.pool.execute(sql5)

    async def create_table_orders_driver(self):
        sql4 = """CREATE TABLE IF NOT EXISTS orders_driver(      
                order_driver_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                route_id BIGINT NOT NULL,

                from_region BIGINT NOT NULL,
                from_town BIGINT,
                to_region BIGINT NOT NULL,
                to_town BIGINT,

                date_trip DATE NOT NULL,
                time_start time NOT NULL,
                time_end time NOT NULL,

                places BIGINT NOT NULL,
                datetime_open timestamp NOT NULL, 
                cancel BOOL
                )"""
        await self.pool.execute(sql4)

    async def create_table_orders_accepted(self):
        sql7 = """CREATE TABLE IF NOT EXISTS orders_accepted(
                order_accept_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                order_client_id BIGINT NOT NULL,
                order_driver_id BIGINT NOT NULL,
                client_id BIGINT NOT NULL,
                driver_id BIGINT NOT NULL,
                phone_client BIGINT NOT NULL,
                phone_driver BIGINT NOT NULL,

                type_of_application VARCHAR(255) NOT NULL,                          

                from_region BIGINT NOT NULL,
                from_town BIGINT NOT NULL,
                to_region BIGINT NOT NULL,
                to_town BIGINT NOT NULL,

                date_trip DATE NOT NULL,
                time_trip VARCHAR(255)[] NOT NULL,
                places BIGINT,
                baggage BIGINT NOT NULL,
                trip BIGINT NOT NULL,

                car BIGINT NOT NULL,
                conditioner BIGINT,

                price BIGINT NOT NULL,
                cost BIGINT NOT NULL,

                datetime_accepted timestamp NOT NULL,
                datetime_cancel timestamp,
                cancel_driver BOOL,
                cancel_client BOOL
                )"""
        #  cancel_driver BOOL,      отмена заказа водителем после принятия заказа
        #  cancel_client BOOL,      отмена заказа клиентом после принятия заказа
        await self.pool.execute(sql7)

    async def create_table_transactions(self):
        sql4 = """CREATE TABLE IF NOT EXISTS transactions(
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        paycom_transaction_id VARCHAR(25) NOT NULL, paycom_time VARCHAR(13) NOT NULL,
        paycom_time_datetime TIMESTAMP NOT NULL, create_time BIGINT NOT NULL,
        perform_time BIGINT NULL, cancel_time BIGINT NULL,
        amount BIGINT NOT NULL, state INT NOT NULL, reason INT NULL,
        receivers VARCHAR(500) NULL, order_id BIGINT 
        )"""
        await self.pool.execute(sql4)

    async def create_table_click_tran(self):
        sql9 = """CREATE TABLE IF NOT EXISTS click(
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        click_trans_id BIGINT,
        click_paydoc_id BIGINT,
        merchant_trans_id VARCHAR,
        amount BIGINT,
        action INT,
        sign_time VARCHAR,
        canceled BOOL
        )"""
        await self.pool.execute(sql9)

    ##################
    async def create_wallet_pay(self):
        sql8 = """CREATE TABLE IF NOT EXISTS wallet_pay(
                pay_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                driver_id BIGINT NOT NULL,
                cash BIGINT NOT NULL,
                type_of_payment VARCHAR(255) NOT NULL,             
                datetime_payment timestamp NOT NULL,
                status BOOL NOT NULL
                )"""
        await self.pool.execute(sql8)

    async def create_table_quiz(self):
        sql = """CREATE TABLE IF NOT EXISTS quiz(
                id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                driver_id BIGINT NOT NULL,
                datetime timestamp NOT NULL
                )"""
        await self.pool.execute(sql)

    async def create_table_analise_client(self):
        sql = """CREATE TABLE IF NOT EXISTS analise_client(
                        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        type_of_application VARCHAR(255) NOT NULL,
                                                  
                        from_region BIGINT,
                        from_town BIGINT,
                        to_region BIGINT,
                        to_town BIGINT,

                        date_trip DATE,
                        time_trip VARCHAR(255)[],
                        places BIGINT,
                        baggage BIGINT,
                        trip BIGINT,
                        phone BIGINT,
                        car BIGINT,
                        
                        driver_id BIGINT,
                        price BIGINT,
                        
                        ordered BOOL,
                        datetime_open timestamp
                        )"""

        # если car = 0 значит не было машин в предложке
        await self.pool.execute(sql)

    async def create_table_analise_driver(self):
        sql = """CREATE TABLE IF NOT EXISTS analise_driver(
                        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        to_cancel BOOL,
                        to_delete BOOL,
                        type_of_route VARCHAR(255), 
                                          
                        from_region BIGINT,
                        to_region BIGINT,
                        from_town BIGINT,
                        to_town BIGINT,

                        conditioner BIGINT,
                        price BIGINT,

                        ordered BOOL,
                        datetime_open timestamp
                        )"""

        # если car = 0 значит не было машин в предложке
        await self.pool.execute(sql)

    ##########################################33
    # exist
    async def exist_client(self, user_id: int):
        sql = """SELECT CASE WHEN EXISTS (SELECT * FROM public.all_users WHERE user_id = $1)
                THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, user_id))[0]

    async def exist_lang(self, user_id: int):
        sql = """SELECT CASE WHEN EXISTS (SELECT * FROM public.all_users 
                WHERE user_id = $1 and language is not NULL)
                THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, user_id))[0]

    async def exist_driver(self, driver_id: int):
        sql = """SELECT CASE WHEN
                EXISTS (SELECT * FROM public.drivers WHERE driver_id = $1)
                THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, driver_id))[0]

    async def name_driver(self, driver_id: int):
        sql = """SELECT name FROM public.drivers WHERE driver_id = $1"""
        return (await self.pool.fetchrow(sql, driver_id))[0]

    # first rec
    async def first_rec_client(self, user_id: int, name: str, username: str, status: bool, deeplink: [str, int]):
        datenow = dt_now.now()
        sql = """INSERT INTO all_users (user_id, name, username, status, datetime_registration, deeplink)
                 VALUES ($1, $2, $3, $4, $5, $6)"""
        await self.pool.execute(sql, user_id, name, username, status, datenow, deeplink)

    async def first_rec_driver(self, driver_id: int, name: str, username: str, phone: int, car: int, wallet: int):
        datenow = dt_now.now()
        sql = """INSERT INTO public.drivers 
        (driver_id, name, username, phone, car, datetime_registration, wallet_main, wallet_bonus, wallet_holiday)
                 VALUES ($1, $2, $3, $4, $5, $6, 0, $7, 0)"""
        await self.pool.execute(sql, driver_id, name, username, phone, car, datenow, wallet)

    async def order_client_rec(self, order_driver_id: int, client_id: int, type_trip: str,
                               from_region: int, from_town: int, to_region: int, to_town: int,
                               date_trip, time_trip: list, baggage: int, trip: int, phone: int,
                               route_id: int, cost: int, places=None):
        datenow = dt_now.now()
        sql = """INSERT INTO public.orders_client(order_driver_id, client_id,   type_of_application,
                                                  from_region, from_town, to_region, to_town,
                                                  date_trip, time_trip, places, baggage, trip, phone,
                                                  route_id, cost,  datetime_open)
        VALUES ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
        RETURNING order_client_id"""
        return (await self.pool.fetchrow(sql, order_driver_id, client_id, type_trip,
                                from_region, from_town, to_region, to_town, date_trip, time_trip, places, baggage,
                                trip, phone, route_id, cost, datenow))[0]

    #
    async def order_driver_rec(self, driver_id: int, name: str, phone: int, car: int,
                               from_region: int, from_towns: list, to_region: int, to_towns: list,
                               conditioner: int, price: int):
        datenow = dt_now.now()
        sql = """INSERT INTO public.route_driver(driver_id, name, phone, car, from_region, from_towns, 
                                                 to_region, to_towns, conditioner, price, datetime_open, cancel)
        VALUES ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, False)"""
        await self.pool.execute(sql, driver_id, name, phone, car, from_region, from_towns, to_region, to_towns,
                                conditioner, price, datenow)

    async def order_accepted_rec(self, order_client_id: int, order_driver_id: int, client_id: int, driver_id: int,
                                 phone_client: int, phone_driver: int, type_of_application: str,
                                 from_region: int, from_town: int, to_region: int, to_town: int,
                                 date_trip, time_trip: list, places: int, baggage: int, trip,
                                 car: int, conditioner: int, price: int, cost: int):
        datenow = dt_now.now()
        sql = """INSERT INTO public.orders_accepted(order_client_id, order_driver_id, client_id, driver_id, 
                                                    phone_client, phone_driver, type_of_application,
                                                    from_region, from_town, to_region, to_town, 
                                                    date_trip, time_trip, places, baggage, trip, 
                                                    car, conditioner, price, cost, datetime_accepted)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 
                $13, $14, $15, $16, $17, $18, $19, $20, $21)"""
        await self.pool.execute(sql, order_client_id, order_driver_id, client_id, driver_id,
                                phone_client, phone_driver, type_of_application,
                                from_region, from_town, to_region, to_town,
                                date_trip, time_trip, places, baggage, trip,
                                car, conditioner, price, cost, datenow)

    async def id_and_region(self, language: str):
        if language == 'rus':
            sql = """SELECT min(region_id) AS region_id,region_rus  FROM public.regions 
                     Group by region_rus ORDER BY region_id ASC"""
            return await self.pool.fetch(sql)
        elif language == 'uzb':
            sql = """SELECT min(region_id) AS region_id,region_uzb  FROM public.regions 
                     Group by region_uzb ORDER BY region_id ASC"""
            return await self.pool.fetch(sql)
        elif language == 'ozb':
            sql = """SELECT min(region_id) AS region_id,region_ozb  FROM public.regions 
                     Group by region_ozb ORDER BY region_id ASC"""
            return await self.pool.fetch(sql)

    async def reg_id_to_towns(self, reg_id: int, language: str):
        if language == 'rus':
            sql = """SELECT region_id, town_rus  FROM public.regions 
                     WHERE region_rus = (SELECT region_rus  FROM public.regions WHERE region_id = $1)"""
            return await self.pool.fetch(sql, reg_id)
        elif language == 'uzb':
            sql = """SELECT region_id, town_uzb  FROM public.regions 
                     WHERE region_uzb = (SELECT region_uzb  FROM public.regions WHERE region_id = $1)"""
            return await self.pool.fetch(sql, reg_id)
        elif language == 'ozb':
            sql = """SELECT region_id, town_ozb  FROM public.regions 
                     WHERE region_ozb = (SELECT region_ozb  FROM public.regions WHERE region_id = $1)"""
            return await self.pool.fetch(sql, reg_id)

    async def id_to_region(self, reg_id: int, language: str):
        if language == 'rus':
            sql = """SELECT region_rus  FROM public.regions WHERE region_id = $1"""
            return (await self.pool.fetchrow(sql, reg_id))[0]
        elif language == 'uzb':
            sql = """SELECT region_uzb  FROM public.regions WHERE region_id = $1"""
            return (await self.pool.fetchrow(sql, reg_id))[0]
        elif language == 'ozb':
            sql = """SELECT region_ozb  FROM public.regions WHERE region_id = $1"""
            return (await self.pool.fetchrow(sql, reg_id))[0]

    async def id_to_town(self, reg_id: int, language: str):
        if language == 'rus':
            sql = 'SELECT town_rus FROM public.regions WHERE region_id = $1'
            return (await self.pool.fetchrow(sql, reg_id))[0]
        elif language == 'uzb':
            sql = 'SELECT town_uzb FROM public.regions WHERE region_id = $1'
            return (await self.pool.fetchrow(sql, reg_id))[0]
        elif language == 'ozb':
            sql = 'SELECT town_ozb FROM public.regions WHERE region_id = $1'
            return (await self.pool.fetchrow(sql, reg_id))[0]

    # car id and value
    async def id_and_car(self):
        sql = 'SELECT * FROM public.cars'
        return await self.pool.fetch(sql)

    async def id_to_car(self, car_id):
        sql = 'SELECT car FROM public.cars WHERE car_id = $1'
        return (await self.pool.fetchrow(sql, car_id))[0]


    # taxi
    # select parametrs & car
    async def route_exist(self, driver_id: int):
        sql = """   SELECT ROUTE_ID FROM PUBLIC.ROUTE_DRIVER 
                     WHERE DRIVER_ID = $1 
                     AND CANCEL = FALSE"""
        return await self.pool.fetchrow(sql, driver_id)

    async def route(self, driver_id: int):
        sql = """    SELECT REGIONS, TOWNS, PRICE FROM PUBLIC.ROUTE_DRIVER 
                     WHERE DRIVER_ID = $1 
                     AND CANCEL = FALSE"""
        return await self.pool.fetchrow(sql, driver_id)

    async def route_cancel(self, driver_id: int, route_id: int):
        datenow = dt_now.now()
        sql = """   UPDATE PUBLIC.ROUTE_DRIVER
                    SET CANCEL = TRUE, DATETIME_CLOSE = $3
                    WHERE DRIVER_ID = $1 AND ROUTE_ID = $2"""
        await self.pool.execute(sql, driver_id, route_id, datenow)

    async def orders_driver_cancel(self, route_id: int):
        sql = """   UPDATE PUBLIC.ORDERS_DRIVER
                    SET CANCEL = TRUE
                    WHERE ROUTE_ID = $1"""
        await self.pool.execute(sql, route_id)

    async def price_update(self, driver_id: int, route_id: int, price: int):
        sql = """   UPDATE PUBLIC.ROUTE_DRIVER
                    SET PRICE = $3
                    WHERE DRIVER_ID = $1 AND ROUTE_ID = $2"""
        await self.pool.execute(sql, driver_id, route_id, price)

#################################################

    async def _unpack_time(self):
        self.__times = []
        self.__time = natsorted(self.__time)
        for i in range(0, len(self.__time)):
            x = self.__time[i].split(" - ")
            self.__times.append(x[0])
            self.__times.append(x[1])

    async def _sort_time(self, i=0):
        await self._unpack_time()
        self.__time = []
        while True:
            try:
                if self.__times[i] == self.__times[i + 1]:
                    self.__times.pop(i + 1)
                    self.__times.pop(i)
                    i = i - 2
                else:
                    i += 1
            except IndexError:
                break
        for i in range(0, len(self.__times)):
            self.__time.append(f"{self.__times[i]}")

    async def times(self, time):
        Time = []
        self.__time = time
        await self._sort_time()
        for i in range(0, len(self.__time), 2):
            time_start = datetime.datetime.strptime(self.__time[i + 0], "%H:%M").time()
            if self.__time[i + 1] == '24:00':
                self.__time[i + 1] = '23:59'
            time_end = datetime.datetime.strptime(self.__time[i + 1], "%H:%M").time()
            Time.append([time_start, time_end])
        return Time

    async def _count(self, times, date, Time=None):
        date = datetime.datetime.strptime(date, "%d.%m.%Y").date()
        times = await self.times(time=times)
        if len(times) == 1:
            Time = "AND FOO.TIME_START <= $7  AND FOO.TIME_END >= $6"
        elif len(times) == 2:
            Time = "AND ((FOO.TIME_START <= $7  AND FOO.TIME_END >= $6) " \
                   "OR (FOO.TIME_START <= $9  AND FOO.TIME_END >= $8))"
        elif len(times) == 3:
            Time = "AND ((FOO.TIME_START <= $7  AND FOO.TIME_END >= $6) " \
                   "OR (FOO.TIME_START <= $9  AND FOO.TIME_END >= $8) " \
                   "OR (FOO.TIME_START <= $11 AND FOO.TIME_END >= $10))"
        elif len(times) == 4:
            Time = "AND ((FOO.TIME_START <= $7  AND FOO.TIME_END >= $6) " \
                   "OR (FOO.TIME_START <= $9  AND FOO.TIME_END >= $8) " \
                   "OR (FOO.TIME_START <= $11 AND FOO.TIME_END >= $10) " \
                   "OR (FOO.TIME_START <= $13 AND FOO.TIME_END >= $12))"
        times = [x for l in times for x in l]
        return Time, times, date

    async def select_count(self, from_region, from_town, to_region, to_town, places, date, client_id, times):
        row = None
        if from_region != to_region:
            row = await self._all_drivers_count_between_region(from_region=from_region, to_region=to_region,
                                                               places=places, date=date, client_id=client_id, times=times)
        elif from_region == to_region:
            row = await self._count_in_region(from_town=from_town, to_town=to_town, date=date,
                                              client_id=client_id, times=times)
        return row

    async def _all_drivers_count_between_region(self, from_region, from_town, to_region, to_town, places, date, client_id, times):
        Time, times, date = await self._time_between_regions(times=times, date=date)
        sql = """   SELECT COUNT(*) FROM (SELECT ROUTE_ID FROM PUBLIC.ROUTE_DRIVER 
                    WHERE  ROUTE_DRIVER.FROM_REGION = $1 
                    AND ROUTE_DRIVER.FROM_TOWN = $2 
                    AND ROUTE_DRIVER.TO_REGION = $3 
                    AND ROUTE_DRIVER.FROM_TOWN = $4 
                    AND ROUTE_DRIVER.CANCEL = FALSE 
                    AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER AS FOO
                                                      WHERE FOO.FROM_REGION = $1 
                                                        AND FOO.TO_REGION = $3
                                                        AND FOO.CANCEL = false
                                                        AND FOO.DATE_TRIP = $6)
                    UNION ALL (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER AS FOO
                               WHERE FOO.FROM_REGION = $1 
                                AND FOO.FROM_TOWN = $2
                                AND FOO.TO_REGION = $3 
                                AND FOO.FROM_TOWN = $4 
                                AND FOO.CANCEL = false
                                AND FOO.DATE_TRIP = $6
                                AND FOO.PLACES >= $5
                                AND FOO.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_CLIENT AS FOO
                                                            WHERE FOO.CLIENT_ID = $7
                                                            AND FOO.FROM_REGION = $1
                                                            AND FOO.TO_REGION = $3
                                                            AND FOO.TYPE_OF_APPLICATION = 'passenger'
                                                            AND FOO.DATE_TRIP = $6)  """
        sql += Time + ")) AS FOO"
        return (await self.pool.fetchrow(sql, from_region, from_town, to_region, to_town, places, date, client_id, *times))[0]

    async def _count_in_region(self, from_town, to_town, date, client_id, times):
        Time, times, date = await self._count(times=times, date=date)
        sql = """   SELECT COUNT(*) FROM (SELECT ROUTE_ID FROM PUBLIC.ROUTE_DRIVER 
                    WHERE $1 = ANY(ROUTE_DRIVER.TOWNS)
                    AND $2 = ANY(ROUTE_DRIVER.TOWNS)
                    AND ROUTE_DRIVER.CANCEL = FALSE
                    AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER AS FOO
                                                      WHERE FOO.FROM_TOWN = $1 
                                                        AND FOO.TO_TOWN = $2
                                                        AND FOO.CANCEL = false
                                                        AND FOO.DATE_TRIP = $4)
                    UNION ALL (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER AS FOO
                               WHERE FOO.FROM_TOWN = $1 
                                AND FOO.TO_TOWN = $2
                                AND FOO.CANCEL = false
                                AND FOO.PLACES <= $3
                                AND FOO.DATE_TRIP = $4
                                AND FOO.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_CLIENT AS FOO
                                                            WHERE FOO.CLIENT_ID = $5
                                                            AND FOO.FROM_TOWN = $1
                                                            AND FOO.TO_TOWN = $2
                                                            AND FOO.TYPE_OF_APPLICATION = 'passenger'
                                                            AND FOO.DATE_TRIP = $4)  """
        sql += Time + ")) AS FOO"
        return (await self.pool.fetchrow(sql, from_town, to_town, 4, date, client_id, *times))[0]

    async def select_distinct_car(self, from_region, from_town, to_region, to_town, places, date, client_id, times):
        row = None
        if from_region != to_region:
            row = await self._car_out_region(from_region=from_region, from_town=from_town,
                                             to_region=to_region, to_town=to_town, places=places, date=date,
                                             client_id=client_id, times=times)
        elif from_region == to_region:
            row = await self._car_in_region(from_region=from_region, from_town=from_town,
                                             to_region=to_region, to_town=to_town, places=places, date=date,
                                             client_id=client_id, times=times)
        return row

    async def _count_car(self, times, date, Time=None):
        date = datetime.datetime.strptime(date, "%d.%m.%Y").date()
        times = await self.times(time=times)
        if len(times) == 1:
            Time = "AND FOO.TIME_START <= $9  AND FOO.TIME_END >= $8"
        elif len(times) == 2:
            Time = "AND ((FOO.TIME_START <= $9  AND FOO.TIME_END >= $8) " \
                   "OR (FOO.TIME_START <= $11  AND FOO.TIME_END >= $10))"
        elif len(times) == 3:
            Time = "AND ((FOO.TIME_START <= $9  AND FOO.TIME_END >= $8) " \
                   "OR (FOO.TIME_START <= $11  AND FOO.TIME_END >= $10) " \
                   "OR (FOO.TIME_START <= $13 AND FOO.TIME_END >= $12))"
        elif len(times) == 4:
            Time = "AND ((FOO.TIME_START <= $9  AND FOO.TIME_END >= $8) " \
                   "OR (FOO.TIME_START <= $11  AND FOO.TIME_END >= $10) " \
                   "OR (FOO.TIME_START <= $13 AND FOO.TIME_END >= $11) " \
                   "OR (FOO.TIME_START <= $15 AND FOO.TIME_END >= $14))"
        times = [x for l in times for x in l]
        return Time, times, date

    async def _car_out_region(self, from_region, from_town, to_region, to_town, places, date, client_id, times):
        Time, times, date = await self._count_car(times=times, date=date)
        sql = """   SELECT FOO.CAR, COUNT(*)  FROM PUBLIC.ROUTE_DRIVER AS FOO
                    WHERE ROUTE_ID IN (SELECT ROUTE_ID FROM PUBLIC.ROUTE_DRIVER 
                        WHERE  ROUTE_DRIVER.FROM_REGION = $1 
                        AND $2 = ANY(ROUTE_DRIVER.FROM_TOWNS) 
                        AND ROUTE_DRIVER.TO_REGION = $3 
                        AND $4 = ANY(ROUTE_DRIVER.TO_TOWNS)
                        AND ROUTE_DRIVER.CANCEL = FALSE 
                        AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER as FOO
                                                          WHERE FOO.FROM_REGION = $1 
                                                            AND FOO.TO_REGION = $3
                                                            AND FOO.CANCEL = false
                                                            AND FOO.DATE_TRIP = $6)
                        UNION ALL (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER AS FOO
                                   WHERE FOO.FROM_REGION = $1 
                                        AND FOO.FROM_TOWN = $2
                                        AND FOO.TO_REGION = $3 
                                        AND FOO.TO_TOWN = $4 
                                        AND FOO.CANCEL = false
                                        AND FOO.DATE_TRIP = $6
                                        AND FOO.PLACES >= $5
                                    AND FOO.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_CLIENT AS FOO
                                                                WHERE FOO.CLIENT_ID = $7
                                                                AND FOO.FROM_REGION = $1
                                                                AND FOO.TO_REGION = $3
                                                                AND FOO.TYPE_OF_APPLICATION = 'passenger'
                                                                AND FOO.DATE_TRIP = $6) """
        sql += Time + ")) GROUP BY FOO.CAR"
        return await self.pool.fetch(sql, from_region, from_town, to_region, to_town, places, date, client_id, *times)

    async def _car_in_region(self, from_region, from_town, to_region, to_town, places, date, client_id, times):
        Time, times, date = await self._count_car(times=times, date=date)
        sql = """   SELECT FOO.CAR, COUNT(*)  FROM PUBLIC.ROUTE_DRIVER AS FOO
                    WHERE ROUTE_ID IN (SELECT ROUTE_ID FROM PUBLIC.ROUTE_DRIVER 
                        WHERE  ROUTE_DRIVER.FROM_REGION = $1 
                        AND ($2 = ANY(ROUTE_DRIVER.FROM_TOWNS) OR $2 = ANY(ROUTE_DRIVER.TO_TOWNS))
                        AND ROUTE_DRIVER.TO_REGION = $3 
                        AND ($4 = ANY(ROUTE_DRIVER.TO_TOWNS) OR $4 = ANY(ROUTE_DRIVER.FROM_TOWNS))
                        AND ROUTE_DRIVER.CANCEL = FALSE 
                        AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER as FOO
                                                          WHERE FOO.FROM_REGION = $1 
                                                            AND FOO.TO_REGION = $3
                                                            AND FOO.CANCEL = false
                                                            AND FOO.DATE_TRIP = $6)
                        UNION ALL (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER AS FOO
                                    WHERE FOO.FROM_REGION = $1 
                                        AND FOO.FROM_TOWN = $2
                                        AND FOO.TO_REGION = $3 
                                        AND FOO.TO_TOWN = $4 
                                        AND FOO.CANCEL = false
                                        AND FOO.DATE_TRIP = $6
                                        AND FOO.PLACES >= $5
                                    AND FOO.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_CLIENT as FOO
                                                                WHERE FOO.CLIENT_ID = $7
                                                                AND FOO.FROM_REGION = $1
                                                                AND FOO.TO_REGION = $3
                                                                AND FOO.TYPE_OF_APPLICATION = 'passenger'
                                                                AND FOO.DATE_TRIP = $6) """
        sql += Time + ")) GROUP BY FOO.CAR"
        return await self.pool.fetch(sql, from_region, from_town, to_region, to_town, places, date, client_id, *times)

    async def select_parametrs(self, from_region, from_town, to_region, to_town, places, date, car, client_id, times):
        row = None
        if from_region != to_region:
            row = await self._parameters_out_region(from_region=from_region, from_town=from_town,
                                                    to_region=to_region, to_town=to_town, places=places,
                                                    date=date, client_id=client_id, times=times, car=car)
        elif from_region == to_region:

            row = await self._parameters_in_region(from_region=from_region, from_town=from_town,
                                                    to_region=to_region, to_town=to_town, places=places,
                                                    date=date, client_id=client_id, times=times, car=car)
        return row

    async def _parameters_out_region(self, from_region, from_town, to_region, to_town, places, date, client_id, times, car):
        Time, times, date = await self._count_car(times=times, date=date)
        x = len(times)
        print(x)
        sql = """   SELECT ROUTE_DRIVER.ROUTE_ID, ROUTE_DRIVER.PRICE, ROUTE_DRIVER.CONDITIONER, FOO.PLACES
                    FROM (SELECT ROUTE_ID, 4 AS PLACES FROM PUBLIC.ROUTE_DRIVER 
                    WHERE ROUTE_ID IN (SELECT ROUTE_ID FROM PUBLIC.ROUTE_DRIVER 
                        WHERE  ROUTE_DRIVER.FROM_REGION = $1 
                        AND $2 = ANY(ROUTE_DRIVER.FROM_TOWNS) 
                        AND ROUTE_DRIVER.TO_REGION = $3 
                        AND $4 = ANY(ROUTE_DRIVER.TO_TOWNS)
                        AND ROUTE_DRIVER.CANCEL = FALSE 
                        AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER as FOO
                                                          WHERE FOO.FROM_REGION = $1 
                                                            AND FOO.TO_REGION = $3
                                                            AND FOO.CANCEL = false
                                                            AND FOO.DATE_TRIP = $6))
                        UNION ALL (SELECT ROUTE_ID, FOO.PlACES FROM PUBLIC.ORDERS_DRIVER AS FOO
                                   WHERE FOO.FROM_REGION = $1 
                                        AND FOO.FROM_TOWN = $2
                                        AND FOO.TO_REGION = $3 
                                        AND FOO.TO_TOWN = $4 
                                        AND FOO.CANCEL = false
                                        AND FOO.DATE_TRIP = $6
                                        AND FOO.PLACES >= $5
                                    AND FOO.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_CLIENT as FOO
                                                                WHERE FOO.CLIENT_ID = $7
                                                                AND FOO.FROM_REGION = $1
                                                                AND FOO.TO_REGION = $3
                                                                AND FOO.TYPE_OF_APPLICATION = 'passenger'
                                                                AND FOO.DATE_TRIP = $6) """
        sql += Time + f""")) AS FOO 
                             LEFT JOIN PUBLIC.ROUTE_DRIVER ON ROUTE_DRIVER.ROUTE_ID = FOO.ROUTE_ID
                             WHERE ROUTE_DRIVER.CAR = ${8+x} ORDER BY ROUTE_DRIVER.PRICE"""
        print(sql)
        return await self.pool.fetch(sql, from_region, from_town, to_region, to_town, places, date, client_id, *times, car)

    async def _parameters_in_region(self,from_region, from_town, to_region, to_town, places, date, client_id, times, car):
        Time, times, date = await self._count_car(times=times, date=date)
        x = len(times)
        sql = """   SELECT ROUTE_DRIVER.ROUTE_ID, ROUTE_DRIVER.PRICE, ROUTE_DRIVER.CONDITIONER, FOO.PLACES
                    FROM (SELECT ROUTE_ID, 4 AS PLACES FROM PUBLIC.ROUTE_DRIVER 
                    WHERE ROUTE_ID IN (SELECT ROUTE_ID FROM PUBLIC.ROUTE_DRIVER 
                        WHERE  ROUTE_DRIVER.FROM_REGION = $1 
                        AND ($2 = ANY(ROUTE_DRIVER.FROM_TOWNS) OR $2 = ANY(ROUTE_DRIVER.TO_TOWNS))
                        AND ROUTE_DRIVER.TO_REGION = $3 
                        AND ($4 = ANY(ROUTE_DRIVER.TO_TOWNS) OR $4 = ANY(ROUTE_DRIVER.FROM_TOWNS))
                        AND ROUTE_DRIVER.CANCEL = FALSE 
                        AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER as FOO
                                                          WHERE FOO.FROM_REGION = $1 
                                                            AND FOO.TO_REGION = $3
                                                            AND FOO.CANCEL = false
                                                            AND FOO.DATE_TRIP = $6)
                        UNION ALL (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER AS FOO
                                   WHERE FOO.FROM_REGION = $1 
                                        AND FOO.FROM_TOWN = $2
                                        AND FOO.TO_REGION = $3 
                                        AND FOO.TO_TOWN = $4 
                                        AND FOO.CANCEL = false
                                        AND FOO.DATE_TRIP = $6
                                        AND FOO.PLACES <= $5
                                    AND FOO.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_CLIENT as FOO
                                                                WHERE FOO.CLIENT_ID = $7
                                                                AND FOO.FROM_REGION = $1
                                                                AND FOO.TO_REGION = $3
                                                                AND FOO.TYPE_OF_APPLICATION = 'passenger'
                                                                AND FOO.DATE_TRIP = $6) """
        sql += Time + f"""))) AS FOO 
                             LEFT JOIN PUBLIC.ROUTE_DRIVER ON ROUTE_DRIVER.ROUTE_ID = FOO.ROUTE_ID
                             WHERE ROUTE_DRIVER.CAR = ${8+x} ORDER BY ROUTE_DRIVER.PRICE"""
        # print(sql)
        return await self.pool.fetch(sql, from_region, from_town, to_region, to_town, 4, date, client_id, *times, car)

    async def select_to_region(self, driver_id: int, from_region: int):
        sql = """   SELECT to_region FROM public.route_driver
                    WHERE from_region = $2
                    AND cancel = False
                    AND driver_id = $1"""
        return await self.pool.fetch(sql, driver_id, from_region)

    async def select_to_towns(self, driver_id: int, region: int):
        sql = """   SELECT unnest(from_towns || to_towns) FROM public.route_driver
                    WHERE from_region = $2
                    AND to_region = $2 
                    AND cancel = False
                    AND driver_id = $1"""
        return await self.pool.fetch(sql, driver_id, region)

    async def _time_between_regions(self, times, date, Time=None):
        date = datetime.datetime.strptime(date, "%d.%m.%Y").date()
        times = await self.times(time=times)
        if len(times) == 1:
            Time = "AND FOO.TIME_START <= $8  AND FOO.TIME_END >= $7"
        elif len(times) == 2:
            Time = "AND ((FOO.TIME_START <= $8  AND FOO.TIME_END >= $7) " \
                   "OR (FOO.TIME_START <= $10  AND FOO.TIME_END >= $9))"
        elif len(times) == 3:
            Time = "AND ((FOO.TIME_START <= $8  AND FOO.TIME_END >= $7) " \
                   "OR (FOO.TIME_START <= $10  AND FOO.TIME_END >= $9) " \
                   "OR (FOO.TIME_START <= $12 AND FOO.TIME_END >= $11))"
        elif len(times) == 4:
            Time = "AND ((FOO.TIME_START <= $8  AND FOO.TIME_END >= $7) " \
                   "OR (FOO.TIME_START <= $10  AND FOO.TIME_END >= $9) " \
                   "OR (FOO.TIME_START <= $12 AND FOO.TIME_END >= $11) " \
                   "OR (FOO.TIME_START <= $14 AND FOO.TIME_END >= $13))"
        times = [x for l in times for x in l]
        return Time, times, date

    async def select_between_regions(self, from_region: int, from_towns: int, to_region: int, places: int,
                                     date, client_id: int, times):
        Time, times, date = await self._time_between_regions(times=times, date=date)
        sql = """   SELECT MAIN_TABLE.twn, COUNT(*) FROM(SELECT unnest(to_towns) as twn, ROUTE_DRIVER .route_id 
                    FROM PUBLIC.ROUTE_DRIVER 
                        WHERE ROUTE_DRIVER.FROM_REGION = $1
                        AND $2 = ANY(ROUTE_DRIVER.FROM_TOWNS)
                        AND ROUTE_DRIVER.TO_REGION = $3
                        AND ROUTE_DRIVER.CANCEL = FALSE
                        AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER as SMALL1
                                                          WHERE SMALL1.FROM_TOWN = $2
                                                            AND SMALL1.TO_REGION = $3
                                                            AND SMALL1.CANCEL = false
                                                            AND SMALL1.DATE_TRIP = $5)
                    UNION ALL (SELECT TO_TOWN as twn, FOO.route_id FROM PUBLIC.ORDERS_DRIVER AS FOO
                                       WHERE FOO.FROM_TOWN = $2
                                        AND FOO.TO_REGION = $3
                                        AND FOO.CANCEL = false
                                        AND FOO.DATE_TRIP = $5
                                        AND FOO.PLACES >= $4
                                        AND FOO.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_CLIENT as SMALL3
                                                                    WHERE SMALL3.CLIENT_ID = $6
                                                                    AND SMALL3.FROM_TOWN = $2
                                                                    AND SMALL3.TO_REGION = $3
                                                                    AND SMALL3.TYPE_OF_APPLICATION = 'passenger'
                                                                    AND SMALL3.DATE_TRIP = $5) """
        sql += Time + f""")) AS MAIN_TABLE
                            LEFT JOIN PUBLIC.ROUTE_DRIVER ON ROUTE_DRIVER.ROUTE_ID = MAIN_TABLE.ROUTE_ID
							GROUP BY MAIN_TABLE.twn"""
        return await self.pool.fetch(sql,  from_region, from_towns, to_region, places, date, client_id, *times)

    async def select_between_towns(self, from_region: int, from_towns: int, to_region: int, places: int,
                                     date, client_id: int, times):
        Time, times, date = await self._time_between_regions(times=times, date=date)
        sql = """   SELECT MAIN_TABLE.twn, COUNT(*) FROM(SELECT unnest(to_towns) as twn, ROUTE_DRIVER .route_id 
                    FROM PUBLIC.ROUTE_DRIVER 
                        WHERE ROUTE_DRIVER.FROM_REGION = $1
                        AND $2 = ANY(ROUTE_DRIVER.FROM_TOWNS) 
                        AND ROUTE_DRIVER.TO_REGION = $3
                        AND ROUTE_DRIVER.CANCEL = FALSE
                        AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER as SMALL1
                                                          WHERE SMALL1.FROM_TOWN = $2
                                                            AND SMALL1.TO_REGION = $3
                                                            AND SMALL1.CANCEL = false
                                                            AND SMALL1.DATE_TRIP = $5)
                    UNION ALL (SELECT unnest(from_towns) as twn, ROUTE_DRIVER .route_id 
                    FROM PUBLIC.ROUTE_DRIVER 
                        WHERE ROUTE_DRIVER.FROM_REGION = $1
                        AND $2 = ANY(ROUTE_DRIVER.TO_TOWNS)
                        AND ROUTE_DRIVER.TO_REGION = $3
                        AND ROUTE_DRIVER.CANCEL = FALSE
                        AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER as SMALL1
                                                          WHERE SMALL1.FROM_TOWN = $2
                                                            AND SMALL1.TO_REGION = $3
                                                            AND SMALL1.CANCEL = false
                                                            AND SMALL1.DATE_TRIP = $5)) 
                    UNION ALL (SELECT TO_TOWN as twn, FOO.route_id FROM PUBLIC.ORDERS_DRIVER AS FOO
                                       WHERE FOO.FROM_TOWN = $2
                                        AND FOO.TO_REGION = $3
                                        AND FOO.CANCEL = false
                                        AND FOO.DATE_TRIP = $5
                                        AND FOO.PLACES >= $4
                                        AND FOO.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_CLIENT as SMALL3
                                                                    WHERE SMALL3.CLIENT_ID = $6
                                                                    AND SMALL3.FROM_TOWN = $2
                                                                    AND SMALL3.TO_REGION = $3
                                                                    AND SMALL3.TYPE_OF_APPLICATION = 'passenger'
                                                                    AND SMALL3.DATE_TRIP = $5) """
        sql += Time + f""")) AS MAIN_TABLE
                            LEFT JOIN PUBLIC.ROUTE_DRIVER ON ROUTE_DRIVER.ROUTE_ID = MAIN_TABLE.ROUTE_ID
                            GROUP BY MAIN_TABLE.twn"""

        print(sql)
        return await self.pool.fetch(sql, from_region, from_towns, to_region, places, date, client_id, *times)

    async def select_driver_to_delivery(self, from_region: int, from_towns: int, to_region: int, to_towns: int,
                                        date, client_id, times):
        self.__Time, times, date = await self._count_delivery(times=times, date=date)
        type_app = "delivery"
        if from_region != to_region:
            await self._delivery_between_regions()
        else:
            await self._delivery_between_towns()
        return await self.pool.fetch(self.__sql, from_region, from_towns, to_region, to_towns, type_app, date, client_id, *times)

    async def _count_delivery(self, times, date, Time=None):
        date = datetime.datetime.strptime(date, "%d.%m.%Y").date()
        times = await self.times(time=times)
        if len(times) == 1:
            Time = "AND FOO.TIME_START <= $9  AND FOO.TIME_END >= $8"
        elif len(times) == 2:
            Time = "AND ((FOO.TIME_START <= $9  AND FOO.TIME_END >= $8) " \
                   "OR (FOO.TIME_START <= $11  AND FOO.TIME_END >= $10))"
        elif len(times) == 3:
            Time = "AND ((FOO.TIME_START <= $9  AND FOO.TIME_END >= $8) " \
                   "OR (FOO.TIME_START <= $11  AND FOO.TIME_END >= $10) " \
                   "OR (FOO.TIME_START <= $13 AND FOO.TIME_END >= $12))"
        elif len(times) == 4:
            Time = "AND ((FOO.TIME_START <= $9  AND FOO.TIME_END >= $8) " \
                   "OR (FOO.TIME_START <= $11  AND FOO.TIME_END >= $10) " \
                   "OR (FOO.TIME_START <= $13 AND FOO.TIME_END >= $12) " \
                   "OR (FOO.TIME_START <= $15 AND FOO.TIME_END >= $14))"
        times = [x for l in times for x in l]
        return Time, times, date

    async def _delivery_between_regions(self):
        self.__sql = """   SELECT ROUTE_DRIVER.ROUTE_ID, ROUTE_DRIVER.DRIVER_ID
                            FROM (SELECT ROUTE_ID FROM PUBLIC.ROUTE_DRIVER
                                WHERE from_region = $1
                                AND to_region = $3
                                AND $2 = any(from_towns) 
                                AND $4 = any(to_towns)
                                AND ROUTE_DRIVER.CANCEL = FALSE
                                AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER as FOO
                                                                  WHERE FOO.FROM_REGION = $1 
                                                                    AND FOO.TO_REGION = $3
                                                                    AND FOO.CANCEL = false
                                                                    AND FOO.DATE_TRIP = $6)
                                UNION ALL (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER AS FOO
                                           WHERE FOO.FROM_REGION = $1 
                                            AND FOO.TO_REGION = $3
                                            AND FOO.FROM_TOWN = $2
                                            AND FOO.TO_TOWN = $4 
                                            AND FOO.CANCEL = false
                                            AND FOO.DATE_TRIP = $6
                                            AND FOO.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_CLIENT as FOO
                                                                        WHERE FOO.CLIENT_ID = $7
                                                                        AND FOO.FROM_REGION = $1
                                                                        AND FOO.TO_REGION = $3
                                                                        AND FOO.TYPE_OF_APPLICATION = $5
                                                                        AND FOO.DATE_TRIP = $6) """
        self.__sql += self.__Time + f""")) AS FOO 
                                     LEFT JOIN PUBLIC.ROUTE_DRIVER ON ROUTE_DRIVER.ROUTE_ID = FOO.ROUTE_ID"""

    async def _delivery_between_towns(self):
        self.__sql = """   SELECT ROUTE_DRIVER.ROUTE_ID, ROUTE_DRIVER.DRIVER_ID
                                    FROM (SELECT ROUTE_ID FROM PUBLIC.ROUTE_DRIVER
                                        WHERE from_region = $1
                                        AND to_region = $3
                                        AND ($2 = any(from_towns) AND $4 = any(to_towns) OR
                                             $2 = any(to_towns) AND $4 = any(from_towns)) 
                                        AND ROUTE_DRIVER.CANCEL = FALSE
                                        AND ROUTE_DRIVER.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER as FOO
                                                                          WHERE FOO.FROM_REGION = $1 
                                                                            AND FOO.TO_REGION = $3
                                                                            AND FOO.CANCEL = false
                                                                            AND FOO.DATE_TRIP = $6)
                                        UNION ALL (SELECT ROUTE_ID FROM PUBLIC.ORDERS_DRIVER AS FOO
                                                   WHERE FOO.FROM_REGION = $1 
                                                    AND FOO.TO_REGION = $3
                                                    AND FOO.FROM_TOWN = $2
                                                    AND FOO.TO_TOWN = $4 
                                                    AND FOO.CANCEL = false
                                                    AND FOO.DATE_TRIP = $6
                                                    AND FOO.ROUTE_ID NOT IN (SELECT ROUTE_ID FROM PUBLIC.ORDERS_CLIENT as FOO
                                                                                WHERE FOO.CLIENT_ID = $7
                                                                                AND FOO.FROM_REGION = $1
                                                                                AND FOO.TO_REGION = $3
                                                                                AND FOO.TYPE_OF_APPLICATION = $5
                                                                                AND FOO.DATE_TRIP = $6) """
        self.__sql += self.__Time + f""")) AS FOO 
                                             LEFT JOIN PUBLIC.ROUTE_DRIVER ON ROUTE_DRIVER.ROUTE_ID = FOO.ROUTE_ID"""

    async def order_driver_exist(self, from_region, to_region, date, times):
        Time, times, date = await self._count(times=times, date=date)
        cancel = False
        exist = True
        sql = """   SELECT CASE WHEN EXISTS 
                    (SELECT * FROM PUBLIC.ORDERS_DRIVER AS FOO
                                           WHERE FOO.FROM_REGION = $1 
                                            AND FOO.TO_REGION = $2
                                            AND FOO.CANCEL = $3
                                            AND FOO.DATE_TRIP = $4 """
        sql += Time + f""") THEN $5 ELSE $3 END"""
        return (await self.pool.fetchrow(sql, from_region, to_region, cancel, date, exist, *times))[0]

######################
    # межрегиональное такси выборка только по регионам

    async def default_parameters_driver(self, driver_id):
        sql = """SELECT driver_id, name, phone, car, conditioner, price FROM public.route_driver
                    WHERE cancel = false AND driver_id=$1"""
        return await self.pool.fetchrow(sql, driver_id)

    async def default_order_driver(self, route_id, from_region,  from_town, to_region, to_town, date):
        datenow = dt_now.now()
        sql = """ INSERT INTO public.orders_driver
                (route_id, from_region,  from_town, to_region, to_town,
                date_trip, time_start, time_end, places, datetime_open, cancel)
                VALUES ($1, $2, $3, $4, $5, $6, time '00:00:00',  time '24:00:00', 4, $7, false)"""
        await self.pool.execute(sql, route_id, from_region,  from_town, to_region, to_town, date, datenow)

    # выбор ордера клиентом, который сделал водитель
    async def select_route_params(self, route_id: int):
        sql = """   SELECT DRIVER_ID, NAME, CONDITIONER, PRICE FROM PUBLIC.ROUTE_DRIVER  
                    WHERE ROUTE_ID = $1"""
        return await self.pool.fetchrow(sql, route_id)

    async def select_places(self, route_id: int, from_region, to_region, date):
        sql = """   SELECT CASE WHEN 
                    EXISTS (SELECT PLACES FROM PUBLIC.ORDERS_DRIVER 
                            WHERE ROUTE_ID = $1
                            AND FROM_REGION = $2 
                            AND TO_REGION = $3
                            AND DATE_TRIP = $4
                            AND CANCEL = false ) 
                            THEN (SELECT PLACES FROM PUBLIC.ORDERS_DRIVER 
                                    WHERE ROUTE_ID = $1
                                    AND FROM_REGION = $2 
                                    AND TO_REGION = $3
                                    AND DATE_TRIP = $4
                                    AND CANCEL = false ) 
                            ELSE 4 
                            END"""
        return (await self.pool.fetch(sql, route_id, from_region, to_region, date))

    async def select_order_driver_id(self, route_id: int, from_region, to_region, date):
        sql = """ SELECT ORDER_DRIVER_ID FROM PUBLIC.ORDERS_DRIVER 
                            WHERE ROUTE_ID = $1
                            AND FROM_REGION = $2 
                            AND TO_REGION = $3
                            AND DATE_TRIP = $4
                            AND CANCEL = false """
        return await self.pool.fetchrow(sql, route_id, from_region, to_region, date)

    async def update_order_time(self, order_driver_id: int, time: list):
        time_start = time[0].split(' - ')[0]
        time_end = time[-1].split(' - ')[-1]
        time_start = datetime.datetime.strptime(time_start, "%H:%M").time()
        if time_end == '24:00':
            time_end = '23:59'
        time_end = datetime.datetime.strptime(time_end, "%H:%M").time()
        sql = """UPDATE PUBLIC.ORDERS_DRIVER
                        SET TIME_START = $2,
                            TIME_END = $3
                        WHERE ORDER_DRIVER_ID = $1"""
        await self.pool.execute(sql, order_driver_id, time_start, time_end)

    # выбор ордера, чтобы узнать какой был присвоен ордер айди ордеру клиента
    async def parametrs_to_order_id_client(self, client_id: int, order_driver_id: int):
        sql = """SELECT MAX("order_client_id") FROM public.orders_client 
                  WHERE client_id = $1 AND 
                  order_driver_id = $2 """
        return (await self.pool.fetchrow(sql, client_id, order_driver_id))[0]

    # выбор ордера водителем, который сделал клиент
    async def new_order_driver(self, order_client_id: int):
        sql = """SELECT order_driver_id, client_id, type_of_application, from_region, from_town, to_region, to_town, 
                  date_trip, time_trip, baggage, places, trip, phone, route_id, cost 
                  FROM public.orders_client WHERE order_client_id = $1"""
        return await self.pool.fetchrow(sql, order_client_id)

    # при отмене водителем ордера, выбор параметров клиента для создания нового ордера
    async def new_order_client(self, order_client_id: int):
        sql = """SELECT phone ,type_of_application, from_region, from_town, to_region, to_town, 
                 date_trip, time_trip, places, baggage, trip, cost, route_id  
                 FROM public.orders_client WHERE order_client_id = $1 """
        return await self.pool.fetchrow(sql, order_client_id)

    async def new_params(self, route_id: int):
        sql = """   SELECT CAR, PRICE FROM PUBLIC.ROUTE_DRIVER WHERE ROUTE_ID = $1"""
        return await self.pool.fetchrow(sql, route_id)

    # active order client
    async def check_active_order_client(self, client_id):
        date = dt_now.now().date()
        print(dt_now.now().date(), dt_now.now())
        sql = """SELECT CASE WHEN
                 EXISTS(SELECT * FROM public.orders_accepted 
                 WHERE client_id = $1 AND date_trip>= $2 AND datetime_cancel is Null)
				 THEN TRUE ELSE FALSE END """
        return (await self.pool.fetchrow(sql, client_id, date))[0]

    # выбор ордера клиентом из активных ордеров
    async def select_order_accepted_to_client(self, client_id):
        date = dt_now.now().date()
        print(dt_now.now().date(), dt_now.now())
        sql = """SELECT order_accept_id 
                  FROM public.orders_accepted 
                  WHERE client_id = $1 AND date_trip >= $2 AND datetime_cancel is NULL"""
        return await self.pool.fetch(sql, client_id, date)

    # выбор ордера клиентом по ордер айди
    async def orderid_to_order_accepted_client(self, order_accept_id):
        sql = """SELECT order_driver_id, driver_id, phone_driver, type_of_application, 
                  from_region, from_town, to_region, to_town, 
                  date_trip, time_trip, places, baggage, trip, car, conditioner, price, cost 
                  FROM public.orders_accepted 
                  WHERE order_accept_id = $1"""
        return await self.pool.fetchrow(sql, order_accept_id)

    # active order driver
    async def check_active_order_driver(self, driver_id):
        date = dt_now.now().date()
        sql = """SELECT CASE WHEN
                 EXISTS(SELECT * FROM public.orders_accepted 
                 WHERE driver_id = $1 AND date_trip>= $2 AND datetime_cancel is Null)
                 THEN TRUE ELSE FALSE END """
        return (await self.pool.fetchrow(sql, driver_id, date))[0]

    async def select_order_accepted_to_driver(self, driver_id):
        date = dt_now.now().date()
        sql = """SELECT order_accept_id, date_trip
                  FROM public.orders_accepted 
                  WHERE driver_id = $1 AND date_trip >= $2 AND datetime_cancel is NULL
                  ORDER BY date_trip ASC"""
        return await self.pool.fetch(sql, driver_id, date)

    # проверка статуса принятия ордера
    async def select_order_client_check(self, order_client_id: int):
        sql = """SELECT CASE WHEN
                 EXISTS (SELECT order_accept FROM public.orders_client 
                 WHERE order_client_id=$1 AND order_accept IS NULL)
                 THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, order_client_id))[0]

    # выбор ордера водителем по ордер айди из активных ордеров
    async def orderid_to_order_accepted_driver(self, order_accept_id):
        date = dt_now.now().date()
        sql = """SELECT order_client_id, client_id, driver_id, phone_client, type_of_application, 
                  from_region, from_town, to_region, to_town, 
                  date_trip, time_trip, places, baggage, trip, price, cost 
                  FROM public.orders_accepted 
                  WHERE order_accept_id = $1 AND date_trip >= $2 AND datetime_cancel is NULL"""
        return await self.pool.fetchrow(sql, order_accept_id, date)


    # выбор всех ордеров водителя по одному направлению, дате, и типу поездки
    async def select_order_accept_driver(self, driver_id: int, type: str, date, from_region: int, to_region: int):
        sql = """SELECT order_accept_id, client_id, time_trip, type_of_application, baggage, cost, places, trip
                 FROM public.orders_accepted
                 WHERE driver_id = $1 AND type_of_application = $2 AND 
                 date_trip = $3 AND from_region = $4 AND to_region = $5 AND datetime_cancel is NULL
                 ORDER BY price DESC"""
        return await self.pool.fetch(sql, driver_id, type, date, from_region, to_region)

    # основные параметры водителя
    async def select_parametrs_driver(self, driver_id):
        sql = 'SELECT name, phone, car FROM public.drivers WHERE driver_id = $1'
        return await self.pool.fetchrow(sql, driver_id)

    async def select_parameters_route(self, route_id):
        sql = 'SELECT name, phone, car, conditioner, price FROM public.route_driver WHERE route_id = $1'
        return await self.pool.fetchrow(sql, route_id)

    async def update_orders_client_cancel(self, client_id: int, type_of_application: str,
                                          from_region: int, from_town: int, to_region: int, to_town: int,
                                          date_trip, time_trip: list, trip: int, route_id: int):
        sql = """UPDATE public.orders_client 
                        SET order_accept = FALSE  
                        WHERE client_id = $1 AND type_of_application = $2 AND  
                        from_region = $3 AND from_town = $4 AND 
                        to_region = $5 AND to_town = $6 AND 
                        date_trip = $7 AND time_trip = $8 AND trip = $9 AND 
                        route_id != $10"""
        await self.pool.execute(sql, client_id, type_of_application, from_region, from_town, to_region, to_town,
                                date_trip, time_trip, trip, route_id)

    async def update_orders_client_accepted(self, order_client_id: int):
        sql = """UPDATE public.orders_client SET order_accept = TRUE WHERE order_client_id = $1 """
        await self.pool.execute(sql, order_client_id)

    async def update_orders_client_rejected(self, order_client_id: int):
        sql = """UPDATE public.orders_client SET order_accept = FALSE WHERE order_client_id = $1 """
        await self.pool.execute(sql, order_client_id)

    # places
    async def update_order_driver_add_places(self, order_driver_id, places):
        sql = """   UPDATE public.orders_driver
                    SET  places = (SELECT places FROM public.orders_driver WHERE order_driver_id = $1) - $2
                    WHERE order_driver_id = $1 """
        await self.pool.execute(sql, order_driver_id, places)

    async def update_order_driver_remove_places(self, order_driver_id: int, places: int):
        sql = """   UPDATE public.orders_driver
                    SET  places = (SELECT places FROM public.orders_driver WHERE order_driver_id = $1) + $2
                    WHERE order_driver_id = $1 """
        await self.pool.execute(sql, order_driver_id, places)

    async def check_places_orders_driver(self, order_driver_id: int):
        sql = """   SELECT places FROM public.orders_driver 
                    WHERE order_driver_id = $1 """
        return (await self.pool.fetchrow(sql, order_driver_id))[0]

    async def cancel_active_order(self, order_accept_id: int, driver=False, client=False):
        datenow = dt_now.now()
        sql = """UPDATE public.orders_accepted 
                SET cancel_driver = $2, cancel_client = $3, datetime_cancel = $4
                WHERE order_accept_id = $1"""
        await self.pool.execute(sql, order_accept_id, driver, client, datenow)

    # delay order
    async def delay_passenger(self, order_client_id):
        sql = """   UPDATE public.orders_client
                    SET  order_accept = False
                    WHERE order_client_id = $1 and order_accept is Null"""
        await self.pool.execute(sql, order_client_id)

    async def delay_delivery(self, client_id: int, type_of_application: str, from_region: int, from_town: int,
                             to_region: int, to_town: int, date_trip, time_trip: list, trip: int):
        sql = """   UPDATE public.orders_client
                    SET  order_accept = False
                    WHERE client_id = $1 AND type_of_application = $2 AND  
                    from_region = $3 AND from_town = $4 AND 
                    to_region = $5 AND to_town = $6 AND 
                    date_trip = $7 AND time_trip = $8 AND trip = $9"""
        await self.pool.execute(sql, client_id, type_of_application, from_region, from_town,
                                to_region, to_town, date_trip, time_trip, trip)

    async def check_order_accept(self, client_id: int, type_of_application: str, from_region: int, from_town: int,
                                 to_region: int, to_town: int, date_trip, time_trip: list, trip: int):
        sql = """SELECT CASE WHEN
                 EXISTS(SELECT * FROM public.orders_accepted 
                 WHERE client_id = $1 AND type_of_application = $2 AND  
                 from_region = $3 AND from_town = $4 AND 
                 to_region = $5 AND to_town = $6 AND 
                 date_trip = $7 AND time_trip = $8 AND trip = $9)
                 THEN TRUE ELSE FALSE END """
        return (await self.pool.fetchrow(sql, client_id, type_of_application, from_region, from_town,
                                         to_region, to_town, date_trip, time_trip, trip))[0]

    async def check_order_reject(self, client_id: int, type_of_application: str, from_region: int, from_town: int,
                                 to_region: int, to_town: int, date_trip, time_trip: list, trip: int):
        sql = """SELECT CASE WHEN EXISTS
                (SELECT * FROM public.orders_client 
                 WHERE client_id = $1 AND type_of_application = $2 AND  
                 from_region = $3 AND from_town = $4 AND 
                 to_region = $5 AND to_town = $6 AND 
                 date_trip = $7 AND time_trip = $8 AND trip = $9 AND order_accept is Null)
                 THEN TRUE ELSE FALSE END """
        return (await self.pool.fetchrow(sql, client_id, type_of_application, from_region, from_town,
                                         to_region, to_town, date_trip, time_trip, trip))[0]

    # personal cabinet
    # name
    async def update_drivers_name(self, driver_id: int, name: str):
        sql = """   UPDATE public.drivers
                    SET  name = $2
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, name)

    async def update_route_driver_name(self, driver_id: int, name: str):
        sql = """   UPDATE public.route_driver
                    SET  name = $2
                    WHERE driver_id = $1 AND cancel = false"""
        await self.pool.execute(sql, driver_id, name)

    # phone
    async def update_drivers_phone(self, driver_id: int, phone: int):
        sql = """   UPDATE public.drivers
                    SET  phone = $2
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, phone)

    async def update_route_driver_phone(self, driver_id: int, phone: int):
        sql = """   UPDATE public.route_driver
                    SET  phone = $2
                    WHERE driver_id = $1 AND cancel = false"""
        await self.pool.execute(sql, driver_id, phone)

    async def update_orders_accepted_phone(self, driver_id: int, phone: int):
        date = dt_now.now().date()
        sql = """   UPDATE public.orders_accepted
                    SET  phone_driver = $2
                    WHERE driver_id = $1 AND date_trip >= $3 AND datetime_cancel IS NULL"""
        await self.pool.execute(sql, driver_id, phone, date)

    # car
    async def update_drivers_car(self, driver_id: int, car: int):
        sql = """   UPDATE public.drivers
                    SET  car = $2
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, car)

    async def update_route_driver_car(self, driver_id: int, car: int):
        sql = """   UPDATE public.route_driver
                    SET  car = $2
                    WHERE driver_id = $1 AND cancel = false"""
        await self.pool.execute(sql, driver_id, car)

    async def update_orders_accepted_car(self, driver_id: int, car: int):
        date = dt_now.now().date()
        sql = """   UPDATE public.orders_accepted
                    SET  car = $2
                    WHERE driver_id = $1 AND date_trip >= $3 AND datetime_cancel IS NULL"""
        await self.pool.execute(sql, driver_id, car, date)

    # wallet
    async def select_all_wallet(self, driver_id: int):
        sql = """SELECT WALLET_MAIN + WALLET_BONUS + WALLET_HOLIDAY AS WALLET_ALL 
                            FROM PUBLIC.DRIVERS
                            WHERE DRIVER_ID = $1"""
        return (await self.pool.fetchrow(sql, driver_id))[0]

    async def select_wallets(self, driver_id: int):
        sql = """SELECT WALLET_MAIN,
                    WALLET_BONUS + WALLET_HOLIDAY
                    FROM PUBLIC.DRIVERS
                    WHERE DRIVER_ID = $1"""
        return await self.pool.fetchrow(sql, driver_id)

    async def select_every_wallet(self, driver_id: int):
        sql = """SELECT WALLET_MAIN, WALLET_BONUS, WALLET_HOLIDAY
                    FROM PUBLIC.DRIVERS
                    WHERE DRIVER_ID = $1"""
        return await self.pool.fetchrow(sql, driver_id)

    async def update_driver_wallet_accept(self, driver_id: int, wallet):
        wallet_main, wallet_bonus, wallet_holiday = wallet
        print(wallet_main, wallet_bonus, wallet_holiday)
        sql = """   UPDATE public.drivers
                    SET   wallet_main=$2 , wallet_bonus=$3 , wallet_holiday=$4
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, wallet_main, wallet_bonus, wallet_holiday)

    async def update_driver_wallet_payment(self, driver_id: int, cash: int):
        sql = """   UPDATE public.drivers
                    SET  wallet_main = (SELECT wallet_main FROM public.drivers WHERE driver_id = $1) + $2
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, cash)

    async def wallet_pay(self, driver_id: int, cash: int, type_of_payment: str, status: bool):
        datenow = dt_now.now()
        sql = """INSERT INTO public.wallet_pay(driver_id, cash, type_of_payment, datetime_payment, status)
                 VALUES ($1, $2, $3, $4, $5)"""
        await self.pool.execute(sql, driver_id, cash, type_of_payment, datenow, status)

    async def select_pay_id(self, driver_id: int, type_of_payment: str, status: bool):
        sql = """SELECT MAX(pay_id) FROM wallet_pay WHERE driver_id = $1 and type_of_payment = $2 and status = $3"""
        return [*await self.pool.fetchrow(sql, driver_id, type_of_payment, status)][0]

    async def update_status(self, status: bool, transaction_id: str):
        sql = """UPDATE wallet_pay SET status = $1 WHERE pay_id = (
        SELECT order_id FROM transactions WHERE paycom_transaction_id = $2)"""
        await self.pool.execute(sql, status, transaction_id)

    # language
    async def select_language(self, user_id: int):
        sql = """SELECT language FROM public.all_users 
                  WHERE user_id = $1 """
        return (await self.pool.fetchrow(sql, user_id))[0]

    async def update_language(self, language: str, user_id: int):
        sql = """UPDATE public.all_users SET language = $1 WHERE user_id = $2"""
        await self.pool.execute(sql, language, user_id)

    # admin
    async def get_users(self, users: str):
        if users == "client":
            return await self.get_clients()
        elif users == "driver":
            return await self.get_driver()
        elif users == 'all':
            return await self.get_all()

    async def get_clients(self):
        sql = """SELECT user_id FROM public.all_users WHERE user_id NOT IN (SELECT driver_id FROM public.drivers)"""
        return await self.pool.fetch(sql)

    async def get_driver(self):
        sql = """SELECT driver_id FROM public.drivers"""
        return await self.pool.fetch(sql)

    async def get_all(self):
        sql = """SELECT user_id FROM public.all_users"""
        return await self.pool.fetch(sql)

    async def get_users_unblock(self, users: str):
        if users == "client":
            return await self.get_clients_unblock()
        elif users == "driver":
            return await self.get_driver_unblock()
        elif users == 'all':
            return await self.get_all_unblock()

    async def get_clients_unblock(self):
        sql = """   SELECT COUNT(*) FROM public.all_users 
                     WHERE user_id NOT IN (SELECT driver_id FROM public.drivers)
                     AND status = TRUE 
                 UNION ALL
                    (SELECT COUNT(*) FROM public.all_users 
                     WHERE user_id NOT IN (SELECT driver_id FROM public.drivers)
                     AND status = FALSE)"""
        return await self.pool.fetch(sql)

    async def get_driver_unblock(self):
        sql = """   SELECT COUNT(*) FROM public.drivers
                    LEFT JOIN PUBLIC.ALL_USERS ON ALL_USERS.USER_ID = DRIVERS.DRIVER_ID
                    WHERE ALL_USERS.STATUS = TRUE
                UNION ALL
                    (SELECT COUNT(*) FROM public.drivers
                    LEFT JOIN PUBLIC.ALL_USERS ON ALL_USERS.USER_ID = DRIVERS.DRIVER_ID
                    WHERE ALL_USERS.STATUS = FALSE)
                """
        return await self.pool.fetch(sql)

    async def get_all_unblock(self):
        sql = """   SELECT COUNT(*) FROM public.all_users WHERE status = TRUE
                UNION ALL
                    (SELECT COUNT(*) FROM public.all_users WHERE status = FALSE)"""
        return await self.pool.fetch(sql)

    # block_status
    async def block_status(self, user_id: int, status: bool):
        sql = """UPDATE public.all_users SET status = $2 WHERE user_id = $1"""
        await self.pool.execute(sql, user_id, status)

    # summary
    # users
    async def all_users(self):
        sql = """SELECT COUNT(*) FROM public.all_users"""
        return (await self.pool.fetchrow(sql))[0]

    async def new_users(self):
        date = dt_now.now().date()
        sql = """SELECT COUNT(*) FROM public.all_users WHERE date(datetime_registration) = $1"""
        return (await self.pool.fetchrow(sql, date))[0]

    # drivers
    async def all_drivers(self):
        sql = """SELECT COUNT(*) FROM public.drivers"""
        return (await self.pool.fetchrow(sql))[0]

    async def new_drivers(self):
        date = dt_now.now().date()
        sql = """SELECT COUNT(*) FROM public.drivers WHERE date(datetime_registration) = $1"""
        return (await self.pool.fetchrow(sql, date))[0]

    # payment
    async def all_payment(self):
        sql = """SELECT COALESCE(SUM(cash),0)::bigint, COALESCE(MAX(cash),0), COALESCE(MIN(cash),0), COUNT(*) 
                FROM public.wallet_pay
                WHERE status = True"""
        return await self.pool.fetchrow(sql)

    async def new_payment(self):
        date = dt_now.now().date()
        sql = """SELECT COALESCE(SUM(cash),0)::bigint, COALESCE(MAX(cash), 0), COALESCE(MIN(cash),0), COUNT(*) 
                FROM public.wallet_pay 
                WHERE date(datetime_payment) = $1
                AND status = True"""
        return await self.pool.fetchrow(sql, date)

    async def all_payment_type(self):
        sql = """SELECT COUNT(*) FROM public.wallet_pay WHERE type_of_payment='Click' AND status = True
                union all SELECT COUNT(*) FROM public.wallet_pay WHERE type_of_payment='Payme' AND status = True
                union all SELECT COUNT(*) FROM public.wallet_pay WHERE type_of_payment='Paynet' AND status = True"""
        return await self.pool.fetch(sql)

    async def all_orders_success(self):
        date = dt_now.now().date()
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'passenger' AND datetime_cancel IS Null AND date_trip < $1
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'delivery' AND datetime_cancel IS Null AND date_trip < $1
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE datetime_cancel IS Null AND date_trip < $1"""
        return await self.pool.fetch(sql, date)

    async def new_orders_success(self):
        date = dt_now.now().date() - datetime.timedelta(days=1)
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'passenger' AND datetime_cancel IS Null AND date_trip = $1
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'delivery' AND datetime_cancel IS Null AND date_trip = $1
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE datetime_cancel IS Null AND date_trip = $1"""
        return await self.pool.fetch(sql, date)

    async def all_order_cancel_client(self):
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'passenger' AND cancel_client=True
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'delivery' AND cancel_client=True
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE cancel_client=True"""
        return await self.pool.fetch(sql)

    async def new_order_cancel_client(self):
        date = dt_now.now().date()
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'passenger' AND cancel_client=True 
                AND date(datetime_cancel) = $1
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'delivery' AND cancel_client=True 
                AND date(datetime_cancel) = $1
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE cancel_client=True AND date(datetime_cancel) = $1"""
        return await self.pool.fetch(sql, date)

    async def all_order_cancel_driver(self):
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'passenger' AND cancel_driver=True
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'delivery' AND cancel_driver=True
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE cancel_driver=True"""
        return await self.pool.fetch(sql)

    async def new_order_cancel_driver(self):
        date = dt_now.now().date()
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'passenger' AND cancel_driver=True 
                AND date(datetime_cancel) = $1
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE type_of_application = 'delivery' AND cancel_driver=True 
                AND date(datetime_cancel) = $1
                union all SELECT COUNT(*) FROM public.orders_accepted 
                WHERE cancel_driver=True AND date(datetime_cancel) = $1"""
        return await self.pool.fetch(sql, date)

    async def cancel_by_client(self):
        sql = """SELECT COALESCE(MAX(n),0), COALESCE(MIN(n),0), COALESCE(AVG(n)::numeric(6,2), 0)
                FROM (SELECT client_id, count(*) as n FROM public.orders_accepted
                WHERE cancel_client=True GROUP BY client_id) AS tbl"""
        return await self.pool.fetchrow(sql)

    async def cancel_by_driver(self):
        sql = """SELECT COALESCE(MAX(n),0), COALESCE(MIN(n),0), COALESCE(AVG(n)::numeric(6,2), 0)
                FROM (SELECT driver_id, count(*) as n FROM public.orders_accepted
                WHERE cancel_driver=True GROUP BY driver_id) AS tbl"""
        return await self.pool.fetchrow(sql)

    # first bonus
    async def time_reminder(self, days: int):
        date = dt_now.now().date()
        sql = f""" SELECT DRIVERS.DRIVER_ID,
                         DRIVERS.WALLET_BONUS,
                         DATE(DRIVERS.DATETIME_REGISTRATION + interval '19 day'),
                         ALL_USERS.LANGUAGE
                        FROM PUBLIC.DRIVERS
                   LEFT JOIN PUBLIC.ALL_USERS ON ALL_USERS.USER_ID = DRIVERS.DRIVER_ID
                   WHERE DATE(DRIVERS.DATETIME_REGISTRATION + interval '{19 - days} day') = $1"""
        return await self.pool.fetch(sql, date)

    async def bonus_end(self):
        date = dt_now.now().date()
        sql = """   UPDATE PUBLIC.DRIVERS
                    SET WALLET_BONUS = 0
                    WHERE DATE(DATETIME_REGISTRATION + interval '20 day') = $1 """
        await self.pool.execute(sql, date)

    async def driver_reminder(self):
        date = dt_now.now().date()
        wallet = Txt.money.wallet.tax
        sql = f""" SELECT DRIVERS.DRIVER_ID,
                          ALL_USERS.LANGUAGE
                          FROM PUBLIC.DRIVERS
                   LEFT JOIN PUBLIC.ALL_USERS ON ALL_USERS.USER_ID = DRIVERS.DRIVER_ID
                   WHERE DATE(DRIVERS.DATETIME_REGISTRATION + interval '19 day') = $1
                         AND DRIVERS.WALLET_MAIN <= $2"""
        return await self.pool.fetch(sql, date, wallet)
    # quiz
    async def exist_quiz(self, driver_id: int):
        sql = """SELECT CASE WHEN EXISTS (SELECT * FROM public.quiz WHERE driver_id = $1)
                THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, driver_id))[0]

    async def add_quiz(self, driver_id: int):
        date = dt_now.now()
        sql = """INSERT INTO public.quiz (driver_id, datetime)
                 VALUES($1, $2)"""
        await self.pool.execute(sql, driver_id, date)

    # database
    async def add_regions(self, regions: List):
        sql = """INSERT INTO regions (region_rus, town_rus, region_uzb, town_uzb, region_ozb, town_ozb)
                 VALUES($1, $2, $3, $4, $5, $6)"""
        await self.pool.executemany(sql, regions)

    async def add_cars(self, cars: List):
        sql = """INSERT INTO cars (car)
                 VALUES($1)"""
        await self.pool.executemany(sql, cars)

    # payme ############################################################################################################
    async def start_order_from_check(self, check: InsertCreatedCheck):
        sql = """INSERT INTO transactions(paycom_transaction_id, 
                                          paycom_time, 
                                          paycom_time_datetime, 
                                          create_time,
                                          perform_time,
                                          cancel_time,
                                          amount,
                                          state,
                                          reason,
                                          receivers,
                                          order_id
                                          ) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11);"""
        await self.pool.execute(sql, *check)

    async def get_order(self, order_id: str) -> int or bool:
        sql = """SELECT order_id FROM transactions WHERE order_id = $1"""
        try:
            return [*await self.pool.fetchrow(sql, int(order_id))][0]
        except TypeError:
            return False

    async def get_state(self, order_id: str) -> int:
        sql = """SELECT state FROM transactions WHERE order_id = $1"""
        try:
            return [*await self.pool.fetchrow(sql, int(order_id))][0]
        except TypeError:
            return 10

    async def get_state_by_transaction_id(self, transaction_id: str) -> int:
        sql = """SELECT state FROM transactions WHERE paycom_transaction_id = $1"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    async def get_amount(self, order_id: str) -> int:
        sql = """SELECT amount FROM transactions WHERE order_id = $1"""
        return [*await self.pool.fetchrow(sql, int(order_id))][0]

    async def select_cash(self, transaction_id: str):
        sql = """SELECT amount FROM transactions WHERE paycom_transaction_id = $1"""
        return int([*await self.pool.fetchrow(sql, transaction_id)][0]/100)

    async def select_current_driver_cash(self, transaction_id: str):
        sql = """SELECT wallet_main FROM drivers WHERE driver_id = (
        SELECT driver_id FROM wallet_pay WHERE pay_id = (
        SELECT order_id FROM transactions WHERE paycom_transaction_id = $1))"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    async def update_cash_to_wallet(self, cash: int, transaction_id: str):
        sql = """UPDATE drivers SET wallet_main = $1 WHERE driver_id = (
        SELECT driver_id FROM wallet_pay WHERE pay_id = (
        SELECT order_id FROM transactions WHERE paycom_transaction_id = $2))"""
        await self.pool.execute(sql, cash, transaction_id)

    async def get_transaction_id(self, transaction_id: str, order_id: str) -> bool:
        sql = """SELECT paycom_transaction_id FROM transactions WHERE paycom_transaction_id = $1 and order_id = $2"""
        return bool(await self.pool.fetchrow(sql, transaction_id, int(order_id)))

    async def get_transaction_by_id(self, transaction_id: str) -> bool:
        sql = """SELECT paycom_transaction_id FROM transactions WHERE paycom_transaction_id = $1"""
        return bool(await self.pool.fetchrow(sql, transaction_id))

    async def get_transaction(self, order_id: str) -> str:
        sql = """SELECT id FROM transactions WHERE order_id = $1"""
        return str([*await self.pool.fetchrow(sql, int(order_id))][0])

    async def get_transaction_incr(self, transaction_id: str) -> str:
        sql = """SELECT id FROM transactions WHERE paycom_transaction_id = $1"""
        return str([*await self.pool.fetchrow(sql, transaction_id)][0])

    async def get_create_time(self, order_id: str, transaction_id: str) -> int:
        sql = """SELECT create_time FROM transactions WHERE order_id = $1 and paycom_transaction_id = $2"""
        return [*await self.pool.fetchrow(sql, int(order_id), transaction_id)][0]

    async def get_create_time_by_transaction_id(self, transaction_id: str) -> int:
        sql = """SELECT create_time FROM transactions WHERE paycom_transaction_id = $1"""
        try:
            return [*await self.pool.fetchrow(sql, transaction_id)][0]
        except TypeError:
            return False

    async def get_perform_time(self, transaction_id):
        sql = """SELECT perform_time FROM transactions WHERE paycom_transaction_id = $1"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    async def get_cancel_time(self, transaction_id):
        sql = """SELECT cancel_time FROM transactions WHERE paycom_transaction_id = $1"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    async def get_reason(self, transaction_id: str):
        sql = """SELECT reason FROM transactions WHERE paycom_transaction_id = $1"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    async def get_user_id(self, transaction_id: str):
        sql = """SELECT order_id FROM transactions WHERE paycom_transaction_id = $1"""
        sql1 = f"""SELECT driver_id FROM wallet_pay WHERE pay_id = ({sql})"""
        return [*await self.pool.fetchrow(sql1, transaction_id)][0]

    async def from_to(self, from_: int, to: int):
        sql = """SELECT paycom_transaction_id, 
                        paycom_time, 
                        amount, 
                        order_id,
                        create_time,
                        perform_time,
                        cancel_time,
                        id,
                        state,
                        reason FROM transactions WHERE create_time > $1 and create_time < $2"""
        return await self.pool.fetch(sql, from_, to)

    async def update_state(self, state: int, order_id: str):
        sql = """UPDATE transactions SET state = $1 WHERE order_id = $2"""
        await self.pool.execute(sql, state, int(order_id))

    async def update_state_by_transaction_id(self, state: int, transaction_id: str):
        sql = """UPDATE transactions SET state = $1 WHERE paycom_transaction_id = $2"""
        await self.pool.execute(sql, state, transaction_id)

    async def update_transaction_id(self, transaction_id: str, order_id: str):
        sql = """UPDATE transactions SET paycom_transaction_id = $1 WHERE order_id = $2"""
        await self.pool.execute(sql, transaction_id, int(order_id))

    async def update_reason(self, reason: int, order_id: str, transaction_id: str):
        sql = """UPDATE transactions SET reason = $1 WHERE order_id = $2 and paycom_transaction_id = $3"""
        await self.pool.execute(sql, reason, int(order_id), transaction_id)

    async def update_reason_by_transaction_id(self, reason: int, transaction_id: str):
        sql = """UPDATE transactions SET reason = $1 WHERE paycom_transaction_id = $2"""
        await self.pool.execute(sql, reason, transaction_id)

    async def update_create_time(self, create_time: int, order_id: str, transaction_id: str):
        sql = """UPDATE transactions SET create_time = $1 WHERE order_id = $2 and paycom_transaction_id = $3"""
        await self.pool.execute(sql, create_time, int(order_id), transaction_id)

    async def update_perform_time(self, perform_time, transaction_id: str):
        sql = """UPDATE transactions SET perform_time = $1 WHERE paycom_transaction_id = $2"""
        await self.pool.execute(sql, perform_time, transaction_id)

    async def update_cansel_time(self, cansel_time: int, transaction_id: str):
        sql = """UPDATE transactions SET cancel_time = $1 WHERE paycom_transaction_id = $2"""
        await self.pool.execute(sql, cansel_time, transaction_id)

    async def get_order_id_from_transaction_id(self, transaction_id: str):
        sql = """SELECT order_id FROM transactions WHERE paycom_transaction_id = $1"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    # click
    async def add_click_order(self, order: InsertCreatedOrder):
        sql = """INSERT into click(click_trans_id, 
                                   click_paydoc_id, 
                                   merchant_trans_id, 
                                   amount,
                                   action,
                                   sign_time,
                                   canceled
                                   ) VALUES($1, $2, $3, $4, $5, $6, $7);"""
        await self.pool.execute(sql, *order)

    async def update_prepare_parameters(self, update: PrepareUpdate):
        sql = """UPDATE click SET click_trans_id = $1, click_paydoc_id = $2, action = $3, sign_time = $4 
                 WHERE merchant_trans_id = $5"""
        await self.pool.execute(sql, *update)

    async def select_prepare_id(self, merchant_trans_id: str) -> int:
        sql = """SELECT id FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def select_sign_time(self, merchant_trans_id: str) -> int:
        sql = """SELECT sign_time FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def select_amount(self, merchant_trans_id: str) -> int:
        sql = """SELECT amount FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def select_action(self, merchant_trans_id: str) -> int:
        sql = """SELECT action FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def update_complete_parameters(self, action: int, sign_time: str, merchant_trans_id: str):
        sql = """UPDATE click SET action = $1, sign_time = $2
                 WHERE merchant_trans_id = $3"""
        await self.pool.execute(sql, action, sign_time, merchant_trans_id)

    async def select_canceled(self, merchant_trans_id: str) -> int:
        sql = """SELECT canceled FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def update_status_click(self, status: bool, merchant_trans_id: str):
        sql = """UPDATE wallet_pay SET status = $1 WHERE pay_id = $2"""
        await self.pool.execute(sql, status, int(merchant_trans_id))

    async def update_cash_to_wallet_click(self, cash: int, merchant_trans_id: str):
        sql = """UPDATE drivers SET wallet_main = $1 WHERE driver_id = (
        SELECT driver_id FROM wallet_pay WHERE pay_id = $2)"""
        await self.pool.execute(sql, cash, int(merchant_trans_id))

    async def select_cash_click(self, merchant_trans_id: str):
        sql = """SELECT amount FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def select_current_cash_driver(self, merchant_trans_id: str):
        sql = """SELECT wallet_main FROM drivers WHERE driver_id = (
        SELECT driver_id FROM wallet_pay WHERE pay_id = $1)"""
        return [*await self.pool.fetchrow(sql, int(merchant_trans_id))][0]

    async def get_user_id_click(self, merchant_trans_id: str):
        sql = """SELECT driver_id FROM wallet_pay WHERE pay_id = $1"""
        return [*await self.pool.fetchrow(sql, int(merchant_trans_id))][0]

    async def update_cancel_trans(self, cancel: bool, merchant_trans_id: str):
        sql = """UPDATE click SET canceled = $1 WHERE merchant_trans_id = $2"""
        await self.pool.execute(sql, cancel, merchant_trans_id)
    ####################################################################################################################

    # analise_client
    async def insert_client(self, user_id: int, type_app: str):
        date = dt_now.now()
        sql = """INSERT into public.analise_client(user_id, type_of_application, datetime_open) 
                 VALUES($1, $2, $3) RETURNING id"""
        return (await self.pool.fetchrow(sql, user_id, type_app, date))[0]

    async def update_from_region(self, id: int, from_region: int):
        sql = """UPDATE public.analise_client 
                 SET from_region = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, id, from_region)

    async def update_from_town(self, id: int, from_town: int):
        sql = """UPDATE public.analise_client 
                 SET from_town = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, id, from_town)

    async def update_to_region(self, id: int, to_region: int):
        sql = """UPDATE public.analise_client 
                 SET to_region = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, id, to_region)

    async def update_to_town(self, id: int, to_town: int):
        sql = """UPDATE public.analise_client 
                 SET to_town = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, id, to_town)

    async def update_datetime(self, id: int, date, time: list):
        date = datetime.datetime.strptime(date, "%d.%m.%Y").date()
        sql = """UPDATE public.analise_client 
                 SET date_trip = $2, time_trip = $3
                 WHERE id = $1"""
        await self.pool.execute(sql, id, date, time)

    async def update_num_baggage(self, id: int, num: int, baggage: int):
        sql = """UPDATE public.analise_client 
                 SET places = $2, baggage = $3
                 WHERE id = $1"""
        await self.pool.execute(sql, id, num, baggage)

    async def update_baggage(self, id: int, baggage: int, price: int):
        sql = """UPDATE public.analise_client 
                 SET places = 0, baggage = $2, price = $3, driver_id = 0, car = 0
                 WHERE id = $1"""
        await self.pool.execute(sql, id, baggage, price)

    async def update_trip(self, id: int, trip: int):
        sql = """UPDATE public.analise_client 
                 SET trip = $2
                 WHERE id = $1 AND trip IS NULL"""
        await self.pool.execute(sql, id, trip)

    async def update_phone(self, id: int, phone: int):
        sql = """UPDATE public.analise_client 
                 SET phone = $2
                 WHERE id = $1"""
        await self.pool.execute(sql, id, phone)

    async def update_model(self, id: int, car: int):
        sql = """UPDATE public.analise_client 
                 SET car = $2
                 WHERE id = $1"""
        await self.pool.execute(sql, id, car)

    async def update_driver(self, id: int, driver_id: int, price: int):
        sql = """UPDATE public.analise_client 
                 SET driver_id = $2, price = $3
                 WHERE id = $1 AND driver_id IS NULL AND price IS NULL"""
        await self.pool.execute(sql, id, driver_id, price)

    async def update_ordered(self, id: int):
        sql = """UPDATE public.analise_client 
                 SET ordered = TRUE
                 WHERE id = $1 AND ordered IS NULL"""
        await self.pool.execute(sql, id)

    # analise_driver
    async def insert_driver(self, user_id: int):
        date = dt_now.now()
        sql = """INSERT INTO public.analise_driver(user_id, datetime_open) 
                 VALUES($1, $2) RETURNING id"""
        return (await self.pool.fetchrow(sql, user_id, date))[0]

    async def update_cancel_driver(self, id: int):
        sql = """UPDATE public.analise_driver 
                         SET to_cancel = True
                         WHERE id = $1"""
        await self.pool.execute(sql, id)

    async def update_delete_driver(self, id: int):
        sql = """UPDATE public.analise_driver 
                         SET to_delete = True
                         WHERE id = $1"""
        await self.pool.execute(sql, id)

    async def update_type_driver(self, id: int, type_app: str):
        sql = """UPDATE public.analise_driver 
                 SET type_of_route = $2, to_cancel = False, to_delete = False
                 WHERE id = $1"""
        await self.pool.execute(sql, id, type_app)

    async def update_from_region_driver(self, id: int, from_region: int):
        sql = """UPDATE public.analise_driver 
                 SET from_region = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, id, from_region)

    async def update_to_region_driver(self, id: int, to_region: int):
        sql = """UPDATE public.analise_driver 
                 SET to_region = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, id, to_region)

    async def update_towns_driver(self, id: int, from_town: int, to_town: int):
        sql = """UPDATE public.analise_driver 
                 SET from_town = $2, to_town = $3
                 WHERE id = $1"""
        await self.pool.execute(sql, id, from_town, to_town)

    async def update_conditioner(self, id: int, conditioner: int):
        sql = """UPDATE public.analise_driver 
                 SET conditioner = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, id, conditioner)

    async def update_price(self, id: int, price: int):
        sql = """UPDATE public.analise_driver 
                 SET price = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, id, price)

    async def update_ordered_driver(self, id: int):
        sql = """UPDATE public.analise_driver 
                 SET ordered = TRUE
                 WHERE id = $1 AND ordered IS NULL"""
        await self.pool.execute(sql, id)

    async def count_clients(self):
        # sql = """SELECT COUNT(*) FROM public.all_users"""
        sql = """SELECT COUNT(*) FROM public.all_users WHERE user_id NOT IN (SELECT driver_id FROM public.drivers)"""
        return (await self.pool.fetchrow(sql))[0]

    async def count_drivers(self):
        sql = """SELECT COUNT(*) FROM public.drivers"""
        return (await self.pool.fetchrow(sql))[0]

    async def analise_taxi_all_time(self):
        sql = """	SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE TYPE_OF_APPLICATION = 'passenger'
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE FROM_REGION IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE FROM_TOWN IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE TO_REGION IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE TO_TOWN IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE DATE_TRIP IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE PLACES IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE TRIP IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE PHONE IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE CAR IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE CAR IS NOT NULL AND CAR = 0 AND TYPE_OF_APPLICATION = 'passenger'
                        and USER_ID NOT IN (SELECT DISTINCT USER_ID FROM PUBLIC.ANALISE_CLIENT
		                WHERE CAR IS NOT NULL AND CAR != 0 AND TYPE_OF_APPLICATION = 'passenger'))
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE DRIVER_ID IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE ORDERED IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger')
        """
        return await self.pool.fetch(sql)

    async def analise_taxi_timeframe(self, days: int):
        date = dt_now.now().date() - datetime.timedelta(days=days)
        sql = """	SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE TYPE_OF_APPLICATION = 'passenger' AND date(datetime_open) >= $1
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE FROM_REGION IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE FROM_TOWN IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE TO_REGION IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE TO_TOWN IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE DATE_TRIP IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE PLACES IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE TRIP IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE PHONE IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE CAR IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE CAR IS NOT NULL AND CAR = 0 AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1
                        AND USER_ID NOT IN (SELECT DISTINCT USER_ID FROM PUBLIC.ANALISE_CLIENT
		                WHERE CAR IS NOT NULL AND CAR != 0 AND TYPE_OF_APPLICATION = 'passenger' 
		                AND date(datetime_open) >= $1))
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE DRIVER_ID IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
                UNION ALL
                    (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                        WHERE ORDERED IS NOT NULL AND TYPE_OF_APPLICATION = 'passenger' 
                        AND date(datetime_open) >= $1)
        """
        return await self.pool.fetch(sql, date)

    async def analise_delivery_all_time(self):
        sql = """		SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE TYPE_OF_APPLICATION = 'delivery'
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE FROM_REGION IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery')
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE FROM_TOWN IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery')
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE TO_REGION IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery')
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE TO_TOWN IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery')
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE DATE_TRIP IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery')
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE BAGGAGE IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery')
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE TRIP IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery')
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE PHONE IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery')
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE ORDERED IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery')
        """
        return await self.pool.fetch(sql)

    async def analise_delivery_timeframe(self, days: int):
        date = dt_now.now().date() - datetime.timedelta(days=days)
        sql = """		SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE TYPE_OF_APPLICATION = 'delivery' 
                            AND date(datetime_open) >= $1
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE FROM_REGION IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery' 
                            AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE FROM_TOWN IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery' 
                            AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE TO_REGION IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery' 
                            AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE TO_TOWN IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery' 
                            AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE DATE_TRIP IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery' 
                            AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE BAGGAGE IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery' 
                            AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE TRIP IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery' 
                            AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE PHONE IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery' 
                            AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                            WHERE ORDERED IS NOT NULL AND TYPE_OF_APPLICATION = 'delivery' 
                            AND date(datetime_open) >= $1)
        """
        return await self.pool.fetch(sql, date)

    async def analise_online_all_time(self):
        sql = """	    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE TYPE_OF_ROUTE IS NOT NULL)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE FROM_REGION IS NOT NULL)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE FROM_TOWN IS NOT NULL)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE TO_REGION IS NOT NULL)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE TO_TOWN IS NOT NULL)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE CONDITIONER IS NOT NULL)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE PRICE IS NOT NULL)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE ORDERED IS NOT NULL)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE TO_CANCEL IS NOT NULL)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE TO_DELETE IS NOT NULL) 
        """
        return await self.pool.fetch(sql)

    async def analise_online_timeframe(self, days: int):
        date = dt_now.now().date() - datetime.timedelta(days=days)
        sql = """		SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER 
                            WHERE date(datetime_open) >= $1
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE TYPE_OF_ROUTE IS NOT NULL AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE FROM_REGION IS NOT NULL AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE FROM_TOWN IS NOT NULL AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE TO_REGION IS NOT NULL AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE TO_TOWN IS NOT NULL AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE CONDITIONER IS NOT NULL AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE PRICE IS NOT NULL AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE ORDERED IS NOT NULL AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE TO_CANCEL IS NOT NULL AND date(datetime_open) >= $1)
                    UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                            WHERE TO_DELETE IS NOT NULL AND date(datetime_open) >= $1) 
        """
        return await self.pool.fetch(sql, date)


##########
    async def all_route_driver(self, driver_id: int):
        sql = """	SELECT route_id, from_region, from_towns, to_region, to_towns, price
                    FROM public.route_driver
                    WHERE driver_id = $1 AND cancel = False
                    Order BY route_id"""
        return await self.pool.fetch(sql, driver_id)

    async def route_id_to_route(self, route_id: int):
        sql = """    SELECT from_region, from_towns, to_region, to_towns, price FROM PUBLIC.ROUTE_DRIVER 
                     WHERE ROUTE_ID = $1"""
        return await self.pool.fetchrow(sql, route_id)


# loop = asyncio.get_event_loop()
# d = Database(loop)
# print(loop.run_until_complete(d.select_pay_id(driver_id=168530165, type_of_payment="Click", status=False)))
